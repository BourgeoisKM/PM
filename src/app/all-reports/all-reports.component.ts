import { Component, type OnInit } from "@angular/core"
import  { Router } from "@angular/router"
import  { DataService } from "src/app/services/data.service"
import jsPDF from "jspdf"
import html2canvas from "html2canvas"
import * as XLSX from "xlsx"

const VENDOR_MAP: Record<string, string> = {
  "fe85da04-2d40-40eb-86f5-682fde6f9573": "Novacom",
  "c257ad68-2390-425a-9946-f800c48fe8c4": "Geek",
  "8014a694-842d-48fd-9c4d-dc32cf15fb93": "Global Tech",
  "fe2f623f-1900-431f-8684-7659e180a207": "Netis",
  "3aed5813-e6a8-4670-b1f0-775aa4fbe9be": "East Castle",
  // Ajoute ici les autres VendorId connus :
  // 'xxxx-xxxx': 'ATC',
  // 'yyyy-yyyy': 'IHS',
  // etc.
}

interface Report {
  report?: {
    id?: string
    vendorId?: string
    site?: {
      name?: string
      siteId?: string
      province?: string
      region?: string
      siteType?: string
      powerConfiguration?: string
      portfolio?: string
      tenantsNames?: string
      vendorId?: string
    }
    fme?: {
      fullName?: string
      vendorId?: string
    }
    fmeName?: string
    pmType?: string
    pmPlannedDate?: string
    pmActualDate?: string
    status?: string
    isSubmitted?: boolean
    submittedAt?: string
    validationComment?: string
    createdAt?: string
    updatedAt?: string
  }
  sections?: any[]
  [key: string]: any
}

@Component({
  selector: "app-all-reports",
  templateUrl: "./all-reports.component.html",
  styleUrls: ["./all-reports.component.css"],
})
export class AllReportsComponent implements OnInit {
  reports: Report[] = []
  allReportsBackup: Report[] = []
  pagedReports: Report[] = []
  currentPage = 1
  itemsPerPage = 100 // Augment√© √† 100
  totalPages = 0
  totalItems = 0
  loading = true
  initialLoading = true
  error: string | null = null
  filterStartDate: string | null = null
  filterEndDate: string | null = null
  searchTerm = ""
  showSkeleton = true
  Math = Math // Pour utiliser Math dans le template

  currentUser: { role?: string; vendorId?: string; [key: string]: any } | null = null

  // Cache management
  private cacheKey = "reports_cache"
  private cacheTimestamp = "reports_cache_timestamp"
  private cacheExpiry = 5 * 60 * 1000 // 5 minutes en millisecondes

  constructor(
    private data: DataService,
    private router: Router,
  ) {}

  ngOnInit(): void {
    this.data.getCurrentUser().subscribe((user) => {
      this.currentUser = user
      if (!this.currentUser) {
        console.error("Utilisateur non connect√© !")
        this.router.navigate(["/login"])
        return
      }
      this.loadReportsProgressively()
    })
  }

  /** Chargement progressif des rapports avec cache */
  loadReportsProgressively(): void {
    // V√©rifier le cache d'abord
    const cachedData = this.getCachedReports()
    if (cachedData) {
      console.log("üì¶ Chargement depuis le cache")
      this.loadFromCache(cachedData)
      return
    }

    console.log("üåê Chargement depuis le serveur")
    this.loading = true
    this.initialLoading = true
    this.showSkeleton = true
    this.error = null

    this.data.getReports().subscribe(
      (res: Report[]) => {
        if (res && Array.isArray(res) && res.length > 0) {
          let filteredReports = res
          if (this.currentUser?.role === "vendor_admin") {
            filteredReports = res.filter((r) => r?.report?.fme?.vendorId === this.currentUser?.vendorId)
          }

          // Sauvegarder dans le cache
          this.setCachedReports(filteredReports)

          this.allReportsBackup = filteredReports
          this.reports = [...this.allReportsBackup]
          this.totalItems = this.reports.length
          this.currentPage = 1
          this.calculateTotalPages()
          this.setPagedReports()

          setTimeout(() => {
            this.showSkeleton = false
            this.loading = false
            this.initialLoading = false
          }, 800)
        } else {
          this.handleEmptyResponse()
        }
      },
      (err: any) => {
        console.error("Erreur lors du chargement des rapports :", err)
        this.error = "Erreur de chargement des rapports."
        this.showSkeleton = false
        this.loading = false
        this.initialLoading = false
      },
    )
  }

  /** Mapping vendorId -> nom du vendor, fallback sur portfolio */
  getVendorName(report: Report): string {
    const site = report?.report?.site
    if (site?.vendorId && VENDOR_MAP[site.vendorId]) {
      return VENDOR_MAP[site.vendorId]
    }
    return site?.portfolio || "N/A"
  }

  calculateTotalPages(): void {
    this.totalPages = Math.ceil(this.reports.length / this.itemsPerPage)
  }

  setPagedReports(): void {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage
    this.pagedReports = this.reports.slice(startIndex, startIndex + this.itemsPerPage)
  }

  /** Pagination intelligente - affiche seulement les pages pertinentes */
  getVisiblePages(): number[] {
    const delta = 2 // Nombre de pages √† afficher de chaque c√¥t√©
    const range = []
    const rangeWithDots = []

    for (
      let i = Math.max(2, this.currentPage - delta);
      i <= Math.min(this.totalPages - 1, this.currentPage + delta);
      i++
    ) {
      range.push(i)
    }

    if (this.currentPage - delta > 2) {
      rangeWithDots.push(1, -1) // -1 repr√©sente "..."
    } else {
      rangeWithDots.push(1)
    }

    rangeWithDots.push(...range)

    if (this.currentPage + delta < this.totalPages - 1) {
      rangeWithDots.push(-1, this.totalPages) // -1 repr√©sente "..."
    } else if (this.totalPages > 1) {
      rangeWithDots.push(this.totalPages)
    }

    return rangeWithDots
  }

  applyDateFilter(): void {
    if (!this.filterStartDate && !this.filterEndDate) {
      this.reports = [...this.allReportsBackup]
      this.currentPage = 1
      this.calculateTotalPages()
      this.setPagedReports()
      return
    }

    const start = this.filterStartDate ? new Date(this.filterStartDate) : null
    const end = this.filterEndDate ? new Date(this.filterEndDate) : null

    this.reports = this.allReportsBackup.filter((r) => {
      if (!r.report?.pmPlannedDate) return false
      const reportDate = new Date(r.report.pmPlannedDate)
      if (start && end) return reportDate >= start && reportDate <= end
      if (start) return reportDate >= start
      if (end) return reportDate <= end
      return true
    })

    this.currentPage = 1
    this.calculateTotalPages()
    this.setPagedReports()
  }

  resetFilter(): void {
    this.filterStartDate = null
    this.filterEndDate = null
    this.searchTerm = ""
    this.reports = [...this.allReportsBackup]
    this.currentPage = 1
    this.calculateTotalPages()
    this.setPagedReports()
  }

  changePage(page: number): void {
    if (page < 1 || page > this.totalPages || page === -1) return // -1 = dots
    this.currentPage = page
    this.setPagedReports()

    // Scroll vers le haut pour une meilleure UX
    window.scrollTo({ top: 0, behavior: "smooth" })
  }

  applySearch(): void {
    const term = this.searchTerm.trim().toLowerCase()

    this.reports = this.allReportsBackup.filter((report) => {
      const siteName = report.report?.site?.name?.toLowerCase() || ""
      const vendorName = this.getVendorName(report).toLowerCase()
      const fmeName = (report.report?.fme?.fullName || report.report?.fmeName || "").toLowerCase()

      return siteName.includes(term) || vendorName.includes(term) || fmeName.includes(term)
    })

    this.currentPage = 1
    this.calculateTotalPages()
    this.setPagedReports()
  }

  getStatusBadgeClass(status: string | undefined): string {
    switch ((status || "").toLowerCase()) {
      case "closed":
      case "submitted":
      case "approved":
        return "badge bg-success"
      case "open":
      case "draft":
        return "badge bg-warning text-dark"
      case "rejected":
        return "badge bg-danger"
      default:
        return "badge bg-secondary"
    }
  }

  exportPDF(): void {
    const DATA = document.getElementById("rapportTable")
    if (DATA) {
      html2canvas(DATA).then((canvas) => {
        const fileWidth = 210
        const fileHeight = (canvas.height * fileWidth) / canvas.width
        const FILEURI = canvas.toDataURL("image/png")
        const PDF = new jsPDF()
        PDF.addImage(FILEURI, "PNG", 0, 10, fileWidth, fileHeight)
        PDF.save("rapports.pdf")
      })
    }
  }

  private flattenObject(obj: any, prefix = ""): any {
    const result: any = {}
    for (const key in obj) {
      if (!obj.hasOwnProperty(key)) continue
      const value = obj[key]
      const newKey = prefix ? `${prefix}.${key}` : key
      if (value && typeof value === "object" && !Array.isArray(value)) {
        Object.assign(result, this.flattenObject(value, newKey))
      } else {
        result[newKey] = value
      }
    }
    return result
  }

  exportExcel(): void {
    if (!this.reports.length) {
      console.warn("Aucun rapport √† exporter.")
      return
    }

    // --- ORDRE & MAPPING ---
    // 1. Mappings + Section m√©tier
    const SECTION_ORDER = [
      "S√©curit√© du site",
      "G√©n√©rateur",
      "Charges AC du Site",
      "SMPS",
      "Batterie Backup (BBU)",
      "DC Box Orange",
      "DC Box Airtel",
      "DC Box Vodacom",
      "Infrastructure et √âquipement du Tower (Pylon)",
      "Environnement du Site",
      "Fondation du Tower (Pylon)",
      "Commentaires",
    ]
    const SECTION_MAP: Record<string, string> = {
      "S√©curit√© du site": "S√©curit√© du site",
      "Site Security": "S√©curit√© du site",
      "S√©curit√© du Site": "S√©curit√© du site",
      "V√©rification Visuelle de la S√©curit√© du Site": "S√©curit√© du site",
      "Site Security Visual Check": "S√©curit√© du site",
      G√©n√©rateur: "G√©n√©rateur",
      Generator: "G√©n√©rateur",
      "Charges AC du Site": "Charges AC du Site",
      "Charge CC du Site": "Charges AC du Site",
      "Site DC Load": "Charges AC du Site",
      SMPS: "SMPS",
      "Batterie Backup (BBU)": "Batterie Backup (BBU)",
      "Battery Backup": "Batterie Backup (BBU)",
      "Batterie de Secours": "Batterie Backup (BBU)",
      "DC Box Orange": "DC Box Orange",
      "DC Box Airtel": "DC Box Airtel",
      "DC Box Vodacom": "DC Box Vodacom",
      "Infrastructure et √âquipement du Tower (Pylon)": "Infrastructure et √âquipement du Tower (Pylon)",
      "Infrastructure et √âquipement de la Tour": "Infrastructure et √âquipement du Tower (Pylon)",
      "Tower Infrastructure & Equipment": "Infrastructure et √âquipement du Tower (Pylon)",
      "Environnement du Site": "Environnement du Site",
      "Site Environment": "Environnement du Site",
      "Fondation du Tower (Pylon)": "Fondation du Tower (Pylon)",
      "Fondations de la Tour": "Fondation du Tower (Pylon)",
      "Tower Foundations": "Fondation du Tower (Pylon)",
      "Dites nous tout ce que vous avez trouv√© comme probl√®mes sur le site": "Commentaires",
      "Commentaires G√©n√©raux": "Commentaires",
      "General Comments": "Commentaires",
    }
    const ITEM_MAP: Record<string, Record<string, string>> = {
      "S√©curit√© du site": {
        "Quel est le statut de la cl√¥ture du site ?": "Statut de la cl√¥ture",
        "Gate Lock Status": "Statut de la cl√¥ture",
        "Quel type de Cadenas est sur la porte ?": "Type de Cadenas Porte",
        "Quel type de Cadenas est sur le G√©n√©rateur ?": "Type de Cadenas G√©n√©rateur",
        "Le g√©n√©rateur a une ceinture de securit√© ?": "Ceinture de s√©curit√© G√©n√©rateur",
        "Photo de la cl√¥ture du site": "Photo Cl√¥ture",
        "Photo de la Gu√©rite du site": "Photo Gu√©rite",
        "La cloture est construit avec quels types de mat√©riaux ?": "Mat√©riaux Cl√¥ture",
        "Quel est l'√âtat de la balise d'aviation ?": "√âtat Balise Aviation",
        "Vous avez des commentaires sur la s√©curit√© du site ?": "Commentaires S√©curit√©",
      },
      G√©n√©rateur: {
        "Mod√®le du G√©n√©rateur": "Mod√®le du G√©n√©rateur",
        "Generator Model": "Mod√®le du G√©n√©rateur",
        "Capacit√© du G√©n√©rateur": "Capacit√© du G√©n√©rateur",
        "Generator Capacity": "Capacit√© du G√©n√©rateur",
        "Num√©ro de S√©rie": "Num√©ro de S√©rie",
        "Serial Number": "Num√©ro de S√©rie",
        "Quel est l'Index du G√©n√©rateur ?": "Index du G√©n√©rateur",
        "Generator Index": "Index du G√©n√©rateur",
        "Le g√©n√©rateur est sur Dalle (Slab)?": "Sur Dalle (Slab)?",
        "Concrete Slab Present": "Sur Dalle (Slab)?",
        "Type de Batterie du G√©n√©rateur": "Type de Batterie du G√©n√©rateur",
        "DG Battery Type": "Type de Batterie du G√©n√©rateur",
        "Automatism Status": "Automatisme fonctionne ?",
        "L'automatisme fonctionne ?": "Automatisme fonctionne ?",
        "Quels sont les probl√®mes que t'as rencontr√© ?": "Probl√®mes rencontr√©s",
        "Issues Encountered": "Probl√®mes rencontr√©s",
      },
      "Charges AC du Site": {
        "Quel est la Charge Totale du Site ?": "Charge Totale",
        "Quel est la Charge Orange": "Charge Orange",
        "Quel est la Charge Airtel": "Charge Airtel",
        "Quel est la Charge Vodacom": "Charge Vodacom",
      },
      SMPS: {
        "Quel est la Marque du SMPS": "Marque du SMPS",
        "SMPS Brand": "Marque du SMPS",
        "Quel est sa Capacit√© SMPS": "Capacit√© SMPS",
        "Combien des Modules Rectifier sont op√©rationnels ?": "Modules Rectifier op√©rationnels",
        "Combien des Modules Solaires Op√©rationnels (MPPT) ?": "Modules Solaires Op√©rationnels",
        "Combien des Modules Rectifiers sont abim√©s ?": "Modules Rectifiers ab√Æm√©s",
        "Pourquoi les Modules Rectifiers sont abim√©s ?": "Cause Modules Rectifiers ab√Æm√©s",
      },
      "Batterie Backup (BBU)": {
        "Quel est la Marque des BBU": "Marque BBU",
        "Si la marque n'est pas dans la liste, √©crivez la marque": "Autre Marque BBU",
        "Quel est la Capacit√© BBU (AH)": "Capacit√© BBU",
        "Il y a combien des Batteries Backup ?": "Nombre Batteries Backup",
        "Est-ce que les bornes sont graiss√©s ? (Uniquement les Lead Acid)": "Bornes Graiss√©es",
      },
      "DC Box Orange": {
        "Model et taille du Dijoncteur 1 (Orange)": "Disjoncteur 1 Orange",
        "Model et taille du Dijoncteur 2 (Orange)": "Disjoncteur 2 Orange",
        "Model et taille du Dijoncteur 3 (Orange)": "Disjoncteur 3 Orange",
      },
      "DC Box Airtel": {
        "Model et taille du Dijoncteur 1 (Airtel)": "Disjoncteur 1 Airtel",
        "Model et taille du Dijoncteur 2 (Airtel)": "Disjoncteur 2 Airtel",
        "Model et taille du Dijoncteur 3 (Airtel)": "Disjoncteur 3 Airtel",
      },
      "DC Box Vodacom": {
        "Model et taille du Dijoncteur 1 (Vodacom)": "Disjoncteur 1 Vodacom",
        "Model et taille du Dijoncteur 2 (Vodacom)": "Disjoncteur 2 Vodacom",
        "Model et taille du Dijoncteur 3 (Vodacom)": "Disjoncteur 3 Vodacom",
      },
      "Infrastructure et √âquipement du Tower (Pylon)": {
        "Quel est le Nombre d'Antennes GSM": "Nombre Antennes GSM",
        "Quel est le Nombre de Microwave": "Nombre Microwave",
        "Quel est le Nombre d'Unit√©s RRU": "Nombre Unit√©s RRU",
      },
      "Environnement du Site": {
        "Prenez plusieurs photos  de l'Environnement": "Photos Environnement",
      },
      "Fondation du Tower (Pylon)": {
        "Prenez une photo de chaque pieds des Pylon": "Photo Pieds Pylon",
      },
      Commentaires: {
        "Dites nous tout ce que vous avez trouv√© comme probl√®mes sur le site": "Commentaires",
        "Commentaires G√©n√©raux": "Commentaires",
        "General Comments": "Commentaires",
      },
    }

    // --- 1. Collecte dynamique des colonnes ---
    const allSectionLabels: Record<string, Set<string>> = {}
    const allItemIdsByCol: Record<string, Set<string>> = {}

    this.reports.forEach((report) => {
      // G√©rer tous les cas possibles pour sections
      const sectionsArr: any[] = (report as any).sections || (report.report && (report.report as any).sections) || []

      sectionsArr.forEach((section: any) => {
        const sectionRaw = section.title || section.sectionType || "Section inconnue"
        const sectionNorm = SECTION_MAP[sectionRaw] || sectionRaw
        if (!allSectionLabels[sectionNorm]) allSectionLabels[sectionNorm] = new Set()
        ;(section.items || []).forEach((item: any) => {
          if (item.type !== "photo") {
            const labelRaw = item.label || item.type || "Item inconnu"
            const labelNorm = (ITEM_MAP[sectionNorm] && ITEM_MAP[sectionNorm][labelRaw]) || labelRaw
            const colKey = `${sectionNorm} - ${labelNorm}`
            allSectionLabels[sectionNorm].add(labelNorm)

            if (!allItemIdsByCol[colKey]) allItemIdsByCol[colKey] = new Set()
            allItemIdsByCol[colKey].add(item.id)
          }
        })
      })
    })

    // Ordre m√©tier puis les autres
    const allSectionsOrdered = [
      ...SECTION_ORDER.filter((sec) => allSectionLabels[sec]),
      ...Object.keys(allSectionLabels).filter((sec) => !SECTION_ORDER.includes(sec)),
    ]

    const dynamicColumns: string[] = []
    allSectionsOrdered.forEach((section) => {
      Array.from(allSectionLabels[section])
        .sort()
        .forEach((label) => {
          dynamicColumns.push(`${section} - ${label}`)
        })
      dynamicColumns.push(`${section} - Autres`)
    })

    const infoColumns = [
      "Rapport ID",
      "Site",
      "Site ID",
      "Vendor",
      "Province",
      "Region",
      "Site Type",
      "Power Configuration",
      "Tenants",
      "FME",
      "PM Planned Date",
      "PM Actual Date",
      "Status",
      "Type PM",
    ]
    const columns = [...infoColumns, ...dynamicColumns]

    // --- 2. G√©n√©ration des lignes ---
    const dataToExport: any[] = []

    this.reports.forEach((report) => {
      const base = report.report || {}
      const site = base.site || {}
      const fme = base.fme || {}
      const vendorName = this.getVendorName(report)

      // Valeurs : toujours checker les deux niveaux
      const valuesArr: any[] = (report as any).values || (report.report && (report.report as any).values) || []
      const sectionsArr: any[] = (report as any).sections || (report.report && (report.report as any).sections) || []

      // Map itemId ‚Üí value la plus r√©cente
      const latestValuePerItem: Record<string, any> = {}
      valuesArr.forEach((v: any) => {
        if (
          !latestValuePerItem[v.reportItemId] ||
          (v.createdAt &&
            (!latestValuePerItem[v.reportItemId].createdAt ||
              new Date(v.createdAt) > new Date(latestValuePerItem[v.reportItemId].createdAt)))
        ) {
          latestValuePerItem[v.reportItemId] = v
        }
      })

      // Map itemId ‚Üí meta
      const itemMeta: Record<string, { section: string; label: string; type: string }> = {}
      sectionsArr.forEach((section: any) => {
        const sectionRaw = section.title || section.sectionType || "Section inconnue"
        const sectionNorm = SECTION_MAP[sectionRaw] || sectionRaw
        ;(section.items || []).forEach((item: any) => {
          itemMeta[item.id] = { section: sectionNorm, label: item.label, type: item.type }
        })
      })

      // --- G√©n√©ration de la ligne ---
      const row: any = {
        "Rapport ID": base.id,
        Site: site.name || "",
        "Site ID": site.siteId || "",
        Vendor: vendorName,
        Province: site.province || "",
        Region: site.region || "",
        "Site Type": site.siteType || "",
        "Power Configuration": site.powerConfiguration || "",
        Tenants: site.tenantsNames || "",
        FME: fme.fullName || base.fmeName || "",
        "PM Planned Date": base.pmPlannedDate || "",
        "PM Actual Date": base.pmActualDate || "",
        Status: base.status || "",
        "Type PM": base.pmType || "",
      }
      dynamicColumns.forEach((col) => (row[col] = ""))

      // Remplit chaque colonne dynamique par correspondance itemId
      dynamicColumns.forEach((col) => {
        if (col.endsWith(" - Autres")) return // On fait √ßa apr√®s
        const possibleItemIds = allItemIdsByCol[col]
        if (!possibleItemIds) return
        let value = ""
        possibleItemIds.forEach((itemId) => {
          if (latestValuePerItem[itemId] && itemMeta[itemId]?.type !== "photo") {
            value = latestValuePerItem[itemId]?.value ?? ""
          }
        })
        row[col] = value
      })

      // Pour les items non mapp√©s sur une colonne, ajoute dans "Autres"
      const autres: Record<string, string[]> = {}
      Object.keys(latestValuePerItem).forEach((itemId) => {
        const meta = itemMeta[itemId]
        if (!meta || meta.type === "photo") return
        const section = meta.section
        const labelRaw = meta.label
        const labelNorm = (ITEM_MAP[section] && ITEM_MAP[section][labelRaw]) || labelRaw
        const colName = `${section} - ${labelNorm}`
        if (!dynamicColumns.includes(colName)) {
          if (!autres[section]) autres[section] = []
          autres[section].push(`${labelNorm}: ${latestValuePerItem[itemId]?.value ?? ""}`)
        }
      })
      Object.keys(autres).forEach((section) => {
        const colName = `${section} - Autres`
        row[colName] = autres[section].join(" | ")
      })

      dataToExport.push(row)
    })

    // --- 3. Export XLSX ---
    const worksheet = XLSX.utils.json_to_sheet(dataToExport, { header: columns })
    const workbook = XLSX.utils.book_new()
    XLSX.utils.book_append_sheet(workbook, worksheet, "Rapports")
    XLSX.writeFile(workbook, "rapports_groupes.xlsx")
  }

  voirRapport(report: Report): void {
    const reportId = report?.report?.id || report?.["id"]
    if (reportId) {
      this.router.navigate(["/rapport", reportId])
    } else {
      console.warn("L'ID du rapport est introuvable.")
    }
  }

  /** R√©cup√©rer les rapports depuis le cache */
  private getCachedReports(): Report[] | null {
    try {
      const timestamp = localStorage.getItem(this.cacheTimestamp)
      const cachedData = localStorage.getItem(this.cacheKey)

      if (!timestamp || !cachedData) {
        return null
      }

      const cacheAge = Date.now() - Number.parseInt(timestamp)
      if (cacheAge > this.cacheExpiry) {
        // Cache expir√©
        localStorage.removeItem(this.cacheKey)
        localStorage.removeItem(this.cacheTimestamp)
        return null
      }

      return JSON.parse(cachedData)
    } catch (error) {
      console.error("Erreur lors de la lecture du cache:", error)
      return null
    }
  }

  /** Sauvegarder les rapports dans le cache */
  private setCachedReports(reports: Report[]): void {
    try {
      localStorage.setItem(this.cacheKey, JSON.stringify(reports))
      localStorage.setItem(this.cacheTimestamp, Date.now().toString())
    } catch (error) {
      console.error("Erreur lors de la sauvegarde du cache:", error)
    }
  }

  /** Charger depuis le cache */
  private loadFromCache(cachedReports: Report[]): void {
    this.allReportsBackup = cachedReports
    this.reports = [...this.allReportsBackup]
    this.totalItems = this.reports.length
    this.currentPage = 1
    this.calculateTotalPages()
    this.setPagedReports()

    // Chargement instantan√© depuis le cache
    this.showSkeleton = false
    this.loading = false
    this.initialLoading = false
  }

  /** G√©rer la r√©ponse vide */
  private handleEmptyResponse(): void {
    this.error = "Aucun rapport valide trouv√©."
    this.reports = []
    this.pagedReports = []
    this.totalPages = 0
    this.totalItems = 0
    this.showSkeleton = false
    this.loading = false
    this.initialLoading = false
  }

  /** Forcer le rechargement depuis le serveur */
  refreshFromServer(): void {
    localStorage.removeItem(this.cacheKey)
    localStorage.removeItem(this.cacheTimestamp)
    this.loadReportsProgressively()
  }
}
